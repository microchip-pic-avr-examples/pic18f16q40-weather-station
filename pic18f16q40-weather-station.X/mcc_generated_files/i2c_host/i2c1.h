/**
 * A header file generated by I2C1 I2C host driver.
 *
 * @file i2c1.h
 *
 * @defgroup i2c_host_interrupt I2C1_HOST_INTERRUPT
 * @brief This header file contains API prototypes and various data types for the I2C1 host driver.
 *
 * @version I2C1 Driver Version 2.2.1 \n
 * 
 * @version I2C1 Package Version 7.0.0
 */

/*
© [2025] Microchip Technology Inc. and its subsidiaries.

    Subject to your compliance with these terms, you may use Microchip 
    software and any derivatives exclusively with Microchip products. 
    You are responsible for complying with 3rd party license terms  
    applicable to your use of 3rd party software (including open source  
    software) that may accompany Microchip software. SOFTWARE IS ?AS IS.? 
    NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS 
    SOFTWARE, INCLUDING ANY IMPLIED WARRANTIES OF NON-INFRINGEMENT,  
    MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT 
    WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY 
    KIND WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF 
    MICROCHIP HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE 
    FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP?S 
    TOTAL LIABILITY ON ALL CLAIMS RELATED TO THE SOFTWARE WILL NOT 
    EXCEED AMOUNT OF FEES, IF ANY, YOU PAID DIRECTLY TO MICROCHIP FOR 
    THIS SOFTWARE.
*/

#ifndef I2C1_H
#define I2C1_H

/**
 * @misradeviation {advisory,2.5} False positive - A few macros in this file 
 * are used as arguments but are not getting recognized by the tool.
 * This rule ID has been disabled at the project level due to numerous 
 * instances across various files.
 * Consequently, in the application project, this rule ID must be disabled
 * in the MPLAB-X IDE by navigating to Tools>Options>Embedded>MISRA Check.
*/

#include <stdint.h>
#include <stdbool.h>
#include "i2c_host_event_types.h"
#include "i2c_host_interface.h"


#define i2c1_host_host_interface I2C1_Host

#define I2C1_Host_Initialize I2C1_Initialize
#define I2C1_Host_Deinitialize I2C1_Deinitialize
#define I2C1_Host_Write I2C1_Write
#define I2C1_Host_Read I2C1_Read
#define I2C1_Host_WriteRead I2C1_WriteRead
#define I2C1_Host_ErrorGet I2C1_ErrorGet
#define I2C1_Host_CallbackRegister I2C1_CallbackRegister
#define I2C1_Host_IsBusy I2C1_IsBusy

/**
 * @ingroup I2C_HOST
 * @brief Represents an instance of the portable interface structure designed for I2C1 host.
 */
extern const i2c_host_interface_t I2C1_Host;

/**
 * @ingroup i2c_host_interrupt
 * @brief Initializes the I2C1 host module according to the settings specified in the MPLABÂ® Code Configurator Melody UI.
 * @param None.
 * @return None. \n
 */
void I2C1_Initialize(void);

/**
 * @ingroup i2c_host_interrupt
 * @brief Resets the registers to their default Power-on Reset (POR) values.
 * @param None.
 * @return None. \n
 */
void I2C1_Deinitialize(void);

/**
 * @ingroup i2c_host_interrupt
 * @brief Sends data to a client on the bus.
 *        Ensure I2C1 host is initialized using 
 *        I2C1_Initialize() before invoking this function.
 * 
 *        This function attempts to write a specified number of bytes from the data buffer
 *        to a I2C client, identified by the provided address.
 *
 *        The TWI host will generate a Start condition, transmit the data, and then
 *        generate a Stop condition. If the client device responds with a NAK or if a bus 
 *        error occurs, the transfer will be terminated.
 *        The application can call the I2C1_ErrorGet() function to
 *        determine the cause of the error. This function is non-blocking, meaning it initiates the 
 *        bus activity and returns immediately. The transfer is then completed within the peripheral 
 *        interrupt. In Polling mode, the user must call I2C1_Tasks
 *        within the while loop. A new transfer request cannot be initiated while another 
 *        transfer is in progress. If this function is called while another transfer is ongoing, 
 *        it will return false.
 *
 * @param [in] address - 7-bit or 10-bit client address
 * @param [in] data - Pointer to the buffer holding the data to be sent
 * @param [in] dataLength - The total number of bytes to be sent
 * @return True - The request was successfully placed and bus activity has started
 * @return False - The request failed as another transfer was already in progress 
 *                 when this function was called
 */
bool I2C1_Write(uint16_t address, uint8_t *data, size_t dataLength);

/**
 * @ingroup i2c_host_interrupt
 * @brief Reads data from an I2C client on the bus.
 *        Ensure I2C1 host is initialized using 
 *        I2C1_Initialize() before invoking this function.
 * 
 *        This function attempts to read a specified number of bytes received from the I2C
 *        client with the given address into the data buffer. The I2C Host initiates a Start
 *        condition, reads the data, and then generates a Stop condition. If the Client
 *        NAKs the request or a bus error occurs, the transfer is terminated.
 *        The application can call the I2C1_ErrorGet() function to
 *        determine the cause of the error.
 *
 *        This function is non-blocking; it starts the bus activity and returns
 *        immediately. The transfer is completed in the peripheral interrupt.
 *        In Polling mode, the user must call I2C1_Tasks
 *        within the while loop. A new transfer request cannot be initiated while
 *        another transfer is in progress. Calling this function during an ongoing
 *        transfer will result in the function returning false.
 *
 * @param [in] address - 7-bit or 10-bit client address
 * @param [out] data - Pointer to the destination buffer where the received data will be stored
 * @param [in] dataLength - The total number of bytes to be received
 * @return True - The request was successfully placed, and bus activity has started
 * @return False - The request failed as another transfer was already in progress 
 *                 when this function was called
 */
bool I2C1_Read(uint16_t address, uint8_t *data, size_t dataLength);

/**
 * @ingroup i2c_host_interrupt
 * @brief Initiates a data transfer by writing data from the writeData function to the bus 
 *        and subsequently reads data from the Client, storing the received data in the
 *        readData parameter. The function generates a Start condition on the bus and 
 *        transmits the specified number of bytes (writeLength) from the writeData buffer. 
 *        Following this, a Repeated Start condition is inserted, and the function proceeds 
 *        to read the specified number of bytes (readLength) from the client, storing them 
 *        in the readData buffer. A Stop condition is generated after the final byte is received.
 *
 *        If the Client responds with a NAK or a bus error occurs, the transfer is terminated. 
 *        The application can call the I2C1_ErrorGet() function to determine 
 *        the cause of the error.
 *
 *        This function is non-blocking; it initiates the bus activity and returns immediately. 
 *        The transfer is then completed via the peripheral interrupt. In Polling mode, the user 
 *        must call I2C1_Tasks within the while loop. A new transfer request 
 *        cannot be initiated while another transfer is in progress. Calling this function during 
 *        an ongoing transfer will result in the function returning false.
 *
 * @param [in] address - 7-bit or 10-bit client address
 * @param [in] writeData - Pointer to the buffer holding the data to be sent
 * @param [in] writeLength - The total number of bytes to be sent
 * @param [out] readData - Pointer to the destination buffer where the received data will be stored
 * @param [in] readLength - The total number of bytes to be received
 * @return True - The request was successfully placed, and bus activity has started
 * @return False - The request failed as another transfer was already in progress 
 *                 when this function was called
 */
bool I2C1_WriteRead(uint16_t address, uint8_t *writeData, size_t writeLength, uint8_t *readData, size_t readLength);

/**
 * @ingroup i2c_host_interrupt
 * @brief Retrieves the error that occurred during I2C transmission and reception. 
 *        Ensure I2C1 host is initialized using 
 *        I2C1_Initialize() before invoking this function.     
 * @param None.
 * @return I2C_ERROR_NONE - Indicates no error \n
 * @return I2C_ERROR_ADDR_NACK - Indicates that the I2C client did not acknowledge the address \n
 * @return I2C_ERROR_DATA_NACK - Indicates that the I2C client did not acknowledge the data \n
 * @return I2C_ERROR_BUS_COLLISION - Indicates an error caused due to bus collision \n
 */
i2c_host_error_t I2C1_ErrorGet(void);

/**
 * @ingroup i2c_host_interrupt
 * @brief Determines if the I2C bus is currently busy. 
 *        Ensure I2C1 host is initialized using 
 *        I2C1_Initialize() before invoking this function.      
 * @param None.
 * @return True - I2C bus busy
 * @return False - I2C bus is idle
 */
bool I2C1_IsBusy(void);

/**
 * @ingroup i2c_host_interrupt
 * @brief Registers a callback function.
 * @param handler - Pointer to custom callback
 * @return None.
 *
 */
void I2C1_CallbackRegister(void (*callback)(void));

/**
 * @ingroup i2c_host
 * @brief Interrupt Service Routine (ISR) function for all I2C1 interrupts.
 *        Ensure I2C1 host is initialized using 
 *        I2C1_Initialize() before invoking this function.
 * @param None.
 * @return None. \n
 */
void I2C1_ISR(void);

/**
 * @ingroup i2c_host
 * @brief Interrupt Service Routine (ISR) for error interrupts.
 *        Ensure I2C1 host is initialized using 
 *        I2C1_Initialize() before invoking this function.
 * @param None.
 * @return None. \n
 */
void I2C1_ERROR_ISR(void);

/**
 * @ingroup i2c_host
 * @brief Interrupt Service Routine (ISR) for I2C1 receive interrupts.
 * @param None.
 * @return None. \n
 */
void I2C1_RX_ISR(void);

/**
 * @ingroup i2c_host
 * @brief Interrupt Service Routine (ISR) for I2C1 transmit interrupts.
 * @param None.
 * @return None. \n
 */
void I2C1_TX_ISR(void);


#endif /* I2C1_H */